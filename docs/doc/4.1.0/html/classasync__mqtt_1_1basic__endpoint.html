<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>async_mqtt: async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">async_mqtt<span id="projectnumber">&#160;4.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classasync__mqtt_1_1basic__endpoint.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classasync__mqtt_1_1basic__endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>MQTT endpoint corresponding to the connection.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>

<p>Inherits std::enable_shared_from_this&lt; basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt; &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a045005fba8b583a870cde28a58da70bb" id="r_a045005fba8b583a870cde28a58da70bb"><td class="memItemLeft" align="right" valign="top"><a id="a045005fba8b583a870cde28a58da70bb" name="a045005fba8b583a870cde28a58da70bb"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>next_layer_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a></td></tr>
<tr class="memdesc:a045005fba8b583a870cde28a58da70bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type given as NextLayer. <br /></td></tr>
<tr class="separator:a045005fba8b583a870cde28a58da70bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842403c46cb455e467380f28d3a14289" id="r_a842403c46cb455e467380f28d3a14289"><td class="memItemLeft" align="right" valign="top"><a id="a842403c46cb455e467380f28d3a14289" name="a842403c46cb455e467380f28d3a14289"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>strand_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> stream_type::strand_type</td></tr>
<tr class="memdesc:a842403c46cb455e467380f28d3a14289"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of stand that is used MQTT stream exclusive control. <br /></td></tr>
<tr class="separator:a842403c46cb455e467380f28d3a14289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5098e22b58adbee93e452ede78ab1adc" id="r_a5098e22b58adbee93e452ede78ab1adc"><td class="memItemLeft" align="right" valign="top"><a id="a5098e22b58adbee93e452ede78ab1adc" name="a5098e22b58adbee93e452ede78ab1adc"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>packet_variant_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">basic_packet_variant</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>&gt;</td></tr>
<tr class="memdesc:a5098e22b58adbee93e452ede78ab1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of packet_variant. <br /></td></tr>
<tr class="separator:a5098e22b58adbee93e452ede78ab1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1a9fe62d017b44fcc94a7fd9ab090" id="r_a5fc1a9fe62d017b44fcc94a7fd9ab090"><td class="memItemLeft" align="right" valign="top"><a id="a5fc1a9fe62d017b44fcc94a7fd9ab090" name="a5fc1a9fe62d017b44fcc94a7fd9ab090"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>packet_id_t</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> packet_id_type&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>&gt;::type</td></tr>
<tr class="memdesc:a5fc1a9fe62d017b44fcc94a7fd9ab090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of MQTT Packet Identifier. <br /></td></tr>
<tr class="separator:a5fc1a9fe62d017b44fcc94a7fd9ab090"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f4ac8feefc66e49003a30c710695e73" id="r_a3f4ac8feefc66e49003a30c710695e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a842403c46cb455e467380f28d3a14289">strand_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f4ac8feefc66e49003a30c710695e73">strand</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a3f4ac8feefc66e49003a30c710695e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand getter  <br /></td></tr>
<tr class="separator:a3f4ac8feefc66e49003a30c710695e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b578d516addd0e490160d4189dd7b9" id="r_ac6b578d516addd0e490160d4189dd7b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a842403c46cb455e467380f28d3a14289">strand_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6b578d516addd0e490160d4189dd7b9">strand</a> ()</td></tr>
<tr class="memdesc:ac6b578d516addd0e490160d4189dd7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand getter  <br /></td></tr>
<tr class="separator:ac6b578d516addd0e490160d4189dd7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233a774006e1f714495a83279f827997" id="r_a233a774006e1f714495a83279f827997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a233a774006e1f714495a83279f827997">in_strand</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a233a774006e1f714495a83279f827997"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand checker  <br /></td></tr>
<tr class="separator:a233a774006e1f714495a83279f827997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada60e5d8c35b1d668a4edf5d0c332f0b" id="r_ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada60e5d8c35b1d668a4edf5d0c332f0b">next_layer</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:ada60e5d8c35b1d668a4edf5d0c332f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc21bc830ae4ffd4a7803d3bdd166a21" id="r_acc21bc830ae4ffd4a7803d3bdd166a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc21bc830ae4ffd4a7803d3bdd166a21">next_layer</a> ()</td></tr>
<tr class="memdesc:acc21bc830ae4ffd4a7803d3bdd166a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:acc21bc830ae4ffd4a7803d3bdd166a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac421785ffce061dc7792a22b586806e4" id="r_ac421785ffce061dc7792a22b586806e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac421785ffce061dc7792a22b586806e4">lowest_layer</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:ac421785ffce061dc7792a22b586806e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:ac421785ffce061dc7792a22b586806e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f483895a76b9d399ab15c32fc201f81" id="r_a8f483895a76b9d399ab15c32fc201f81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f483895a76b9d399ab15c32fc201f81">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a8f483895a76b9d399ab15c32fc201f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:a8f483895a76b9d399ab15c32fc201f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8920d50890684fc33eab70c709a90f" id="r_a5e8920d50890684fc33eab70c709a90f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8920d50890684fc33eab70c709a90f">set_auto_pub_response</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:a5e8920d50890684fc33eab70c709a90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto publish response setter. Should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call.  <br /></td></tr>
<tr class="separator:a5e8920d50890684fc33eab70c709a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e77ec0b180801e25279d35d225a7771" id="r_a5e77ec0b180801e25279d35d225a7771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e77ec0b180801e25279d35d225a7771">set_auto_ping_response</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:a5e77ec0b180801e25279d35d225a7771"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto pingreq response setter. Should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call.  <br /></td></tr>
<tr class="separator:a5e77ec0b180801e25279d35d225a7771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596d2617fa46cd0f37b40afbf4f912df" id="r_a596d2617fa46cd0f37b40afbf4f912df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a596d2617fa46cd0f37b40afbf4f912df">set_auto_map_topic_alias_send</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:a596d2617fa46cd0f37b40afbf4f912df"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:a596d2617fa46cd0f37b40afbf4f912df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f40da2602fb6b22049aafa815782e0" id="r_a70f40da2602fb6b22049aafa815782e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70f40da2602fb6b22049aafa815782e0">set_auto_replace_topic_alias_send</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:a70f40da2602fb6b22049aafa815782e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:a70f40da2602fb6b22049aafa815782e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5ad61f8f5490ef59836a3dcbdeccf0" id="r_adc5ad61f8f5490ef59836a3dcbdeccf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc5ad61f8f5490ef59836a3dcbdeccf0">set_pingresp_recv_timeout_ms</a> (std::size_t <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">ms</a>)</td></tr>
<tr class="memdesc:adc5ad61f8f5490ef59836a3dcbdeccf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code disconnect_reason_code::keep_alive_timeout automatically before underlying layer is closed. <br  />
 This function should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:adc5ad61f8f5490ef59836a3dcbdeccf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd1123e96908cbee60f7a80a05eb33b" id="r_a6fd1123e96908cbee60f7a80a05eb33b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a6fd1123e96908cbee60f7a80a05eb33b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fd1123e96908cbee60f7a80a05eb33b">acquire_unique_packet_id</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a6fd1123e96908cbee60f7a80a05eb33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:a6fd1123e96908cbee60f7a80a05eb33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1240ba6cc43d3713c64fafc8231a70" id="r_a7f1240ba6cc43d3713c64fafc8231a70"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a7f1240ba6cc43d3713c64fafc8231a70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f1240ba6cc43d3713c64fafc8231a70">acquire_unique_packet_id_wait_until</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a7f1240ba6cc43d3713c64fafc8231a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id. If packet_id is fully acquired, then wait until released.  <br /></td></tr>
<tr class="separator:a7f1240ba6cc43d3713c64fafc8231a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e13edf4c934825c963a6253256b9569" id="r_a1e13edf4c934825c963a6253256b9569"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a1e13edf4c934825c963a6253256b9569"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e13edf4c934825c963a6253256b9569">register_packet_id</a> (<a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> packet_id, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a1e13edf4c934825c963a6253256b9569"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:a1e13edf4c934825c963a6253256b9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff337a148a16117b11e99cd45b716f1" id="r_aaff337a148a16117b11e99cd45b716f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:aaff337a148a16117b11e99cd45b716f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaff337a148a16117b11e99cd45b716f1">release_packet_id</a> (<a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> packet_id, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:aaff337a148a16117b11e99cd45b716f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:aaff337a148a16117b11e99cd45b716f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fd7877fb05e3dd6f28476173be5683" id="r_ad8fd7877fb05e3dd6f28476173be5683"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a> , <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:ad8fd7877fb05e3dd6f28476173be5683"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683">send</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a> packet, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:ad8fd7877fb05e3dd6f28476173be5683"><td class="mdescLeft">&#160;</td><td class="mdescRight">send packet users can call <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> before the previous <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>'s CompletionToken is invoked  <br /></td></tr>
<tr class="separator:ad8fd7877fb05e3dd6f28476173be5683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1d7d1d565ad54bdfb7a7ee347351d5" id="r_a6a1d7d1d565ad54bdfb7a7ee347351d5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a6a1d7d1d565ad54bdfb7a7ee347351d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5">recv</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a6a1d7d1d565ad54bdfb7a7ee347351d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked  <br /></td></tr>
<tr class="separator:a6a1d7d1d565ad54bdfb7a7ee347351d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0dc1b634f77d057271e25c626e6953" id="r_a5d0dc1b634f77d057271e25c626e6953"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a5d0dc1b634f77d057271e25c626e6953"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d0dc1b634f77d057271e25c626e6953">recv</a> (std::set&lt; control_packet_type &gt; types, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a5d0dc1b634f77d057271e25c626e6953"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked.  <br /></td></tr>
<tr class="separator:a5d0dc1b634f77d057271e25c626e6953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf4ab7a004d8649b7787228f118f6a2" id="r_aacf4ab7a004d8649b7787228f118f6a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:aacf4ab7a004d8649b7787228f118f6a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacf4ab7a004d8649b7787228f118f6a2">recv</a> (<a class="el" href="endpoint_8hpp.html#aed6ebca93cac28c67f2b4fb8641e775a">filter</a> fil, std::set&lt; control_packet_type &gt; types, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:aacf4ab7a004d8649b7787228f118f6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. @params fil if <code>match</code> then matched types are targets. if <code>except</code> then not matched types are targets.  <br /></td></tr>
<tr class="separator:aacf4ab7a004d8649b7787228f118f6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a6b00992f24f008a7fad151610c967" id="r_ac5a6b00992f24f008a7fad151610c967"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:ac5a6b00992f24f008a7fad151610c967"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5a6b00992f24f008a7fad151610c967">close</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:ac5a6b00992f24f008a7fad151610c967"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the underlying connection  <br /></td></tr>
<tr class="separator:ac5a6b00992f24f008a7fad151610c967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8cb61f709aef3ec3bd5fc0370bc69f" id="r_a6a8cb61f709aef3ec3bd5fc0370bc69f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a6a8cb61f709aef3ec3bd5fc0370bc69f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a8cb61f709aef3ec3bd5fc0370bc69f">restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt; pvs, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a6a8cb61f709aef3ec3bd5fc0370bc69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:a6a8cb61f709aef3ec3bd5fc0370bc69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2af7cc626ce0c3aab87e12d21dcfc7" id="r_a1c2af7cc626ce0c3aab87e12d21dcfc7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a1c2af7cc626ce0c3aab87e12d21dcfc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c2af7cc626ce0c3aab87e12d21dcfc7">get_stored_packets</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>) <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a1c2af7cc626ce0c3aab87e12d21dcfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets sotred packets mean inflight packets.  <br /></td></tr>
<tr class="separator:a1c2af7cc626ce0c3aab87e12d21dcfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d58c77fd13b77afdbc94a6e3c865b36" id="r_a7d58c77fd13b77afdbc94a6e3c865b36"><td class="memItemLeft" align="right" valign="top">optional&lt; <a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d58c77fd13b77afdbc94a6e3c865b36">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:a7d58c77fd13b77afdbc94a6e3c865b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:a7d58c77fd13b77afdbc94a6e3c865b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91683e5aa2ed234e5c14f79361ff2deb" id="r_a91683e5aa2ed234e5c14f79361ff2deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91683e5aa2ed234e5c14f79361ff2deb">register_packet_id</a> (<a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">pid</a>)</td></tr>
<tr class="memdesc:a91683e5aa2ed234e5c14f79361ff2deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:a91683e5aa2ed234e5c14f79361ff2deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90777e5fde27013cc8d308d501a6ead8" id="r_a90777e5fde27013cc8d308d501a6ead8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90777e5fde27013cc8d308d501a6ead8">release_packet_id</a> (<a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">pid</a>)</td></tr>
<tr class="memdesc:a90777e5fde27013cc8d308d501a6ead8"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:a90777e5fde27013cc8d308d501a6ead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaf7274ef58eadf15428071cae9e894" id="r_a1aaf7274ef58eadf15428071cae9e894"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aaf7274ef58eadf15428071cae9e894">get_qos2_publish_handled_pids</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a1aaf7274ef58eadf15428071cae9e894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get processed but not released QoS2 packet ids This function should be called after disconnection.  <br /></td></tr>
<tr class="separator:a1aaf7274ef58eadf15428071cae9e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4696744f07068176e48e12aeb4998fb0" id="r_a4696744f07068176e48e12aeb4998fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4696744f07068176e48e12aeb4998fb0">restore_qos2_publish_handled_pids</a> (std::set&lt; <a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">pids</a>)</td></tr>
<tr class="memdesc:a4696744f07068176e48e12aeb4998fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore processed but not released QoS2 packet ids This function should be called before receive the first publish.  <br /></td></tr>
<tr class="separator:a4696744f07068176e48e12aeb4998fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe47bd9ab1590e66f110e3dbe1087e" id="r_a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dfe47bd9ab1590e66f110e3dbe1087e">restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt; pvs)</td></tr>
<tr class="memdesc:a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:a6dfe47bd9ab1590e66f110e3dbe1087e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed8d45ffcfb114533d8de5ddddb4f92" id="r_a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ed8d45ffcfb114533d8de5ddddb4f92">get_stored_packets</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets sotred packets mean inflight packets.  <br /></td></tr>
<tr class="separator:a5ed8d45ffcfb114533d8de5ddddb4f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbabd5f427b1cb18d61ac49c7bbf83b" id="r_a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbabd5f427b1cb18d61ac49c7bbf83b">get_protocol_version</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MQTT protocol version  <br /></td></tr>
<tr class="separator:a9cbabd5f427b1cb18d61ac49c7bbf83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23794d3c9fe9385a10a76ca58e9b00c" id="r_ae23794d3c9fe9385a10a76ca58e9b00c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae23794d3c9fe9385a10a76ca58e9b00c">is_publish_processing</a> (<a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">pid</a>) <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:ae23794d3c9fe9385a10a76ca58e9b00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MQTT PUBLISH packet processing status.  <br /></td></tr>
<tr class="separator:ae23794d3c9fe9385a10a76ca58e9b00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e65de9df8df56eb3dca5b09a8c04d00" id="r_a2e65de9df8df56eb3dca5b09a8c04d00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e65de9df8df56eb3dca5b09a8c04d00">regulate_for_store</a> (v5::basic_publish_packet&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &amp;packet) <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a2e65de9df8df56eb3dca5b09a8c04d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regulate publish packet for store If topic is empty, extract topic from topic alias, and remove topic alias Otherwise, remove topic alias if exists.  <br /></td></tr>
<tr class="separator:a2e65de9df8df56eb3dca5b09a8c04d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae3faa98c0f30e8df05ef02a6a1f4ed85" id="r_ae3faa98c0f30e8df05ef02a6a1f4ed85"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae3faa98c0f30e8df05ef02a6a1f4ed85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">static</a> std::shared_ptr&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">this_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3faa98c0f30e8df05ef02a6a1f4ed85">create</a> (<a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">ver</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Args</a> &amp;&amp;... <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">args</a>)</td></tr>
<tr class="memdesc:ae3faa98c0f30e8df05ef02a6a1f4ed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">create  <br /></td></tr>
<tr class="separator:ae3faa98c0f30e8df05ef02a6a1f4ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae37385dccb86c73c3fa61e1f7eec5e23" id="r_ae37385dccb86c73c3fa61e1f7eec5e23"><td class="memItemLeft" align="right" valign="top"><a id="ae37385dccb86c73c3fa61e1f7eec5e23" name="ae37385dccb86c73c3fa61e1f7eec5e23"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">static</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">constexpr</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>packet_id_bytes</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a></td></tr>
<tr class="memdesc:ae37385dccb86c73c3fa61e1f7eec5e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value given as PacketIdBytes. <br /></td></tr>
<tr class="separator:ae37385dccb86c73c3fa61e1f7eec5e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a2e1a75540d6fe007c2a768600ad6d8cb" id="r_a2e1a75540d6fe007c2a768600ad6d8cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </td></tr>
<tr class="memitem:a2e1a75540d6fe007c2a768600ad6d8cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e1a75540d6fe007c2a768600ad6d8cb">endpoint</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, 2, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;</td></tr>
<tr class="memdesc:a2e1a75540d6fe007c2a768600ad6d8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2).  <br /></td></tr>
<tr class="separator:a2e1a75540d6fe007c2a768600ad6d8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;<br />
class async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, NextLayer &gt;</div><p>MQTT endpoint corresponding to the connection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">PacketIdBytes</td><td>MQTT spec is 2. You can use <code>endpoint</code> for that. </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7d58c77fd13b77afdbc94a6e3c865b36" name="a7d58c77fd13b77afdbc94a6e3c865b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d58c77fd13b77afdbc94a6e3c865b36">&#9670;&#160;</a></span>acquire_unique_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;packet_id_t&gt; if acquired return acquired packet id, otherwise nullopt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a6fd1123e96908cbee60f7a80a05eb33b" name="a6fd1123e96908cbee60f7a80a05eb33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd1123e96908cbee60f7a80a05eb33b">&#9670;&#160;</a></span>acquire_unique_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is optional&lt;packet_id_t&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a7f1240ba6cc43d3713c64fafc8231a70" name="a7f1240ba6cc43d3713c64fafc8231a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1240ba6cc43d3713c64fafc8231a70">&#9670;&#160;</a></span>acquire_unique_packet_id_wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::acquire_unique_packet_id_wait_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. If packet_id is fully acquired, then wait until released. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is packet_id_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="ac5a6b00992f24f008a7fad151610c967" name="ac5a6b00992f24f008a7fad151610c967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a6b00992f24f008a7fad151610c967">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>close the underlying connection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="ae3faa98c0f30e8df05ef02a6a1f4ed85" name="ae3faa98c0f30e8df05ef02a6a1f4ed85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3faa98c0f30e8df05ef02a6a1f4ed85">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">static</a> std::shared_ptr&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">this_type</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a></td>          <td class="paramname"><span class="paramname"><em>ver</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types for the next layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ver</td><td>MQTT protocol version client can set v5 or v3_1_1, in addition server can set undetermined </td></tr>
    <tr><td class="paramname">args</td><td>args for the next layer. There are predefined next layer types: <br  />
 <a class="el" href="predefined__underlying__layer_8hpp.html#af0fedc2324340e8a97a85d091e912983">protocol::mqtt</a>, <a class="el" href="predefined__underlying__layer_8hpp.html#ae84d125ae067aa02cb9f8965bbaed3f9">protocol::mqtts</a>, <a class="el" href="predefined__underlying__layer_8hpp.html#aa5faa493592170b84fe10807b67f2a7a">protocol::ws</a>, and <a class="el" href="predefined__underlying__layer_8hpp.html#a3f43ad7309eefaa8f5e4dde369e19212">protocol::wss</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared_ptr of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. </dd></dl>

</div>
</div>
<a id="a9cbabd5f427b1cb18d61ac49c7bbf83b" name="a9cbabd5f427b1cb18d61ac49c7bbf83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbabd5f427b1cb18d61ac49c7bbf83b">&#9670;&#160;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get MQTT protocol version </p>
<dl class="section return"><dt>Returns</dt><dd>MQTT protocol version </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a1aaf7274ef58eadf15428071cae9e894" name="a1aaf7274ef58eadf15428071cae9e894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaf7274ef58eadf15428071cae9e894">&#9670;&#160;</a></span>get_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get processed but not released QoS2 packet ids This function should be called after disconnection. </p>
<dl class="section return"><dt>Returns</dt><dd>set of packet_ids </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a5ed8d45ffcfb114533d8de5ddddb4f92" name="a5ed8d45ffcfb114533d8de5ddddb4f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed8d45ffcfb114533d8de5ddddb4f92">&#9670;&#160;</a></span>get_stored_packets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_stored_packets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get stored packets sotred packets mean inflight packets. </p>
<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS1) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet <dl class="section return"><dt>Returns</dt><dd>std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1c2af7cc626ce0c3aab87e12d21dcfc7" name="a1c2af7cc626ce0c3aab87e12d21dcfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2af7cc626ce0c3aab87e12d21dcfc7">&#9670;&#160;</a></span>get_stored_packets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_stored_packets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get stored packets sotred packets mean inflight packets. </p>
<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS1) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a233a774006e1f714495a83279f827997" name="a233a774006e1f714495a83279f827997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233a774006e1f714495a83279f827997">&#9670;&#160;</a></span>in_strand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::in_strand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand checker </p>
<dl class="section return"><dt>Returns</dt><dd>true if the current context running in the strand, otherwise false </dd></dl>

</div>
</div>
<a id="ae23794d3c9fe9385a10a76ca58e9b00c" name="ae23794d3c9fe9385a10a76ca58e9b00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23794d3c9fe9385a10a76ca58e9b00c">&#9670;&#160;</a></span>is_publish_processing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::is_publish_processing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get MQTT PUBLISH packet processing status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>packet_id corresponding to the publish packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the packet is processing, then true, otherwise false. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a8f483895a76b9d399ab15c32fc201f81" name="a8f483895a76b9d399ab15c32fc201f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f483895a76b9d399ab15c32fc201f81">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="ac421785ffce061dc7792a22b586806e4" name="ac421785ffce061dc7792a22b586806e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac421785ffce061dc7792a22b586806e4">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a>  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="acc21bc830ae4ffd4a7803d3bdd166a21" name="acc21bc830ae4ffd4a7803d3bdd166a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc21bc830ae4ffd4a7803d3bdd166a21">&#9670;&#160;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the next_layer </dd></dl>

</div>
</div>
<a id="ada60e5d8c35b1d668a4edf5d0c332f0b" name="ada60e5d8c35b1d668a4edf5d0c332f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada60e5d8c35b1d668a4edf5d0c332f0b">&#9670;&#160;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a045005fba8b583a870cde28a58da70bb">next_layer_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a>  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the next_layer </dd></dl>

</div>
</div>
<a id="a6a1d7d1d565ad54bdfb7a7ee347351d5" name="a6a1d7d1d565ad54bdfb7a7ee347351d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1d7d1d565ad54bdfb7a7ee347351d5">&#9670;&#160;</a></span>recv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="aacf4ab7a004d8649b7787228f118f6a2" name="aacf4ab7a004d8649b7787228f118f6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf4ab7a004d8649b7787228f118f6a2">&#9670;&#160;</a></span>recv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#aed6ebca93cac28c67f2b4fb8641e775a">filter</a></td>          <td class="paramname"><span class="paramname"><em>fil</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; control_packet_type &gt;</td>          <td class="paramname"><span class="paramname"><em>types</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. @params fil if <code>match</code> then matched types are targets. if <code>except</code> then not matched types are targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a5d0dc1b634f77d057271e25c626e6953" name="a5d0dc1b634f77d057271e25c626e6953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0dc1b634f77d057271e25c626e6953">&#9670;&#160;</a></span>recv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; control_packet_type &gt;</td>          <td class="paramname"><span class="paramname"><em>types</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#a6a1d7d1d565ad54bdfb7a7ee347351d5" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a1e13edf4c934825c963a6253256b9569" name="a1e13edf4c934825c963a6253256b9569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e13edf4c934825c963a6253256b9569">&#9670;&#160;</a></span>register_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>packet_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
    <tr><td class="paramname">token</td><td>the param is bool. If true, success, otherwise the packet_id has already been used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a91683e5aa2ed234e5c14f79361ff2deb" name="a91683e5aa2ed234e5c14f79361ff2deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91683e5aa2ed234e5c14f79361ff2deb">&#9670;&#160;</a></span>register_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If true, success, otherwise the packet_id has already been used. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a2e65de9df8df56eb3dca5b09a8c04d00" name="a2e65de9df8df56eb3dca5b09a8c04d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e65de9df8df56eb3dca5b09a8c04d00">&#9670;&#160;</a></span>regulate_for_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::regulate_for_store </td>
          <td>(</td>
          <td class="paramtype">v5::basic_publish_packet&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regulate publish packet for store If topic is empty, extract topic from topic alias, and remove topic alias Otherwise, remove topic alias if exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to regulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="aaff337a148a16117b11e99cd45b716f1" name="aaff337a148a16117b11e99cd45b716f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff337a148a16117b11e99cd45b716f1">&#9670;&#160;</a></span>release_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>packet_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a90777e5fde27013cc8d308d501a6ead8" name="a90777e5fde27013cc8d308d501a6ead8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90777e5fde27013cc8d308d501a6ead8">&#9670;&#160;</a></span>release_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a6dfe47bd9ab1590e66f110e3dbe1087e" name="a6dfe47bd9ab1590e66f110e3dbe1087e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfe47bd9ab1590e66f110e3dbe1087e">&#9670;&#160;</a></span>restore_packets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>pvs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a6a8cb61f709aef3ec3bd5fc0370bc69f" name="a6a8cb61f709aef3ec3bd5fc0370bc69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8cb61f709aef3ec3bd5fc0370bc69f">&#9670;&#160;</a></span>restore_packets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>pvs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a4696744f07068176e48e12aeb4998fb0" name="a4696744f07068176e48e12aeb4998fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4696744f07068176e48e12aeb4998fb0">&#9670;&#160;</a></span>restore_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::restore_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="#a5fc1a9fe62d017b44fcc94a7fd9ab090">packet_id_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pids</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore processed but not released QoS2 packet ids This function should be called before receive the first publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pids</td><td>packet ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="ad8fd7877fb05e3dd6f28476173be5683" name="ad8fd7877fb05e3dd6f28476173be5683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fd7877fb05e3dd6f28476173be5683">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a> , <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a></td>          <td class="paramname"><span class="paramname"><em>packet</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send packet users can call <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> before the previous <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>'s CompletionToken is invoked </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to send </td></tr>
    <tr><td class="paramname">token</td><td>the param is <a class="el" href="structasync__mqtt_1_1system__error.html" title="async_mqtt error class. It is used as CompletionToken parameter and exception.">system_error</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a596d2617fa46cd0f37b40afbf4f912df" name="a596d2617fa46cd0f37b40afbf4f912df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596d2617fa46cd0f37b40afbf4f912df">&#9670;&#160;</a></span>set_auto_map_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_map_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically mapping. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto mapping, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e77ec0b180801e25279d35d225a7771" name="a5e77ec0b180801e25279d35d225a7771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e77ec0b180801e25279d35d225a7771">&#9670;&#160;</a></span>set_auto_ping_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_ping_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto pingreq response setter. Should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8920d50890684fc33eab70c709a90f" name="a5e8920d50890684fc33eab70c709a90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8920d50890684fc33eab70c709a90f">&#9670;&#160;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto publish response setter. Should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f40da2602fb6b22049aafa815782e0" name="a70f40da2602fb6b22049aafa815782e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f40da2602fb6b22049aafa815782e0">&#9670;&#160;</a></span>set_auto_replace_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_replace_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically replacing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto replacing, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc5ad61f8f5490ef59836a3dcbdeccf0" name="adc5ad61f8f5490ef59836a3dcbdeccf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5ad61f8f5490ef59836a3dcbdeccf0">&#9670;&#160;</a></span>set_pingresp_recv_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_pingresp_recv_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code disconnect_reason_code::keep_alive_timeout automatically before underlying layer is closed. <br  />
 This function should be called before <a class="el" href="#ad8fd7877fb05e3dd6f28476173be5683" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default timeout is not set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if 0, timer is not set, otherwise set val milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b578d516addd0e490160d4189dd7b9" name="ac6b578d516addd0e490160d4189dd7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b578d516addd0e490160d4189dd7b9">&#9670;&#160;</a></span>strand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a842403c46cb455e467380f28d3a14289">strand_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::strand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the strand </dd></dl>

</div>
</div>
<a id="a3f4ac8feefc66e49003a30c710695e73" name="a3f4ac8feefc66e49003a30c710695e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4ac8feefc66e49003a30c710695e73">&#9670;&#160;</a></span>strand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a842403c46cb455e467380f28d3a14289">strand_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a>  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::strand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the strand </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a2e1a75540d6fe007c2a768600ad6d8cb" name="a2e1a75540d6fe007c2a768600ad6d8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1a75540d6fe007c2a768600ad6d8cb">&#9670;&#160;</a></span>endpoint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a> <a class="el" href="#a2e1a75540d6fe007c2a768600ad6d8cb">endpoint</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, 2, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/async_mqtt/include/async_mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>async_mqtt</b></li><li class="navelem"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
