<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>async_mqtt: async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, Strand, NextLayer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">async_mqtt<span id="projectnumber">&#160;5.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classasync__mqtt_1_1basic__endpoint.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classasync__mqtt_1_1basic__endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, Strand, NextLayer &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>MQTT endpoint corresponding to the connection.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>

<p>Inherits std::enable_shared_from_this&lt; basic_endpoint&lt; Role, PacketIdBytes, Strand, NextLayer &gt; &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a20be5a44c6ac697b8d6e6e4b4a578647" id="r_a20be5a44c6ac697b8d6e6e4b4a578647"><td class="memItemLeft" align="right" valign="top"><a id="a20be5a44c6ac697b8d6e6e4b4a578647" name="a20be5a44c6ac697b8d6e6e4b4a578647"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>next_layer_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a></td></tr>
<tr class="memdesc:a20be5a44c6ac697b8d6e6e4b4a578647"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type given as NextLayer. <br /></td></tr>
<tr class="separator:a20be5a44c6ac697b8d6e6e4b4a578647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9d540dac0d5efa243c5f6f7c17e42" id="r_af9e9d540dac0d5efa243c5f6f7c17e42"><td class="memItemLeft" align="right" valign="top"><a id="af9e9d540dac0d5efa243c5f6f7c17e42" name="af9e9d540dac0d5efa243c5f6f7c17e42"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>strand_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> stream_type::strand_type</td></tr>
<tr class="memdesc:af9e9d540dac0d5efa243c5f6f7c17e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of stand that is used MQTT stream exclusive control. <br /></td></tr>
<tr class="separator:af9e9d540dac0d5efa243c5f6f7c17e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78defa26c26671e19bc9ef05d0ef44d9" id="r_a78defa26c26671e19bc9ef05d0ef44d9"><td class="memItemLeft" align="right" valign="top"><a id="a78defa26c26671e19bc9ef05d0ef44d9" name="a78defa26c26671e19bc9ef05d0ef44d9"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>packet_variant_type</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">basic_packet_variant</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>&gt;</td></tr>
<tr class="memdesc:a78defa26c26671e19bc9ef05d0ef44d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of packet_variant. <br /></td></tr>
<tr class="separator:a78defa26c26671e19bc9ef05d0ef44d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac549d8d2701f3aaa2fab51a44c7f1" id="r_aa7ac549d8d2701f3aaa2fab51a44c7f1"><td class="memItemLeft" align="right" valign="top"><a id="aa7ac549d8d2701f3aaa2fab51a44c7f1" name="aa7ac549d8d2701f3aaa2fab51a44c7f1"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>packet_id_t</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> packet_id_type&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>&gt;::type</td></tr>
<tr class="memdesc:aa7ac549d8d2701f3aaa2fab51a44c7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of MQTT Packet Identifier. <br /></td></tr>
<tr class="separator:aa7ac549d8d2701f3aaa2fab51a44c7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f523ba7d97ab371165c62fa954f6dab" id="r_a8f523ba7d97ab371165c62fa954f6dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9e9d540dac0d5efa243c5f6f7c17e42">strand_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f523ba7d97ab371165c62fa954f6dab">strand</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a8f523ba7d97ab371165c62fa954f6dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand getter  <br /></td></tr>
<tr class="separator:a8f523ba7d97ab371165c62fa954f6dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a6bbeb0124a2ccf2b746bd5c8e6039" id="r_a35a6bbeb0124a2ccf2b746bd5c8e6039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9e9d540dac0d5efa243c5f6f7c17e42">strand_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35a6bbeb0124a2ccf2b746bd5c8e6039">strand</a> ()</td></tr>
<tr class="memdesc:a35a6bbeb0124a2ccf2b746bd5c8e6039"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand getter  <br /></td></tr>
<tr class="separator:a35a6bbeb0124a2ccf2b746bd5c8e6039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6010146d8beed3b7de005e59ac3f24d4" id="r_a6010146d8beed3b7de005e59ac3f24d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6010146d8beed3b7de005e59ac3f24d4">in_strand</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a6010146d8beed3b7de005e59ac3f24d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">strand checker  <br /></td></tr>
<tr class="separator:a6010146d8beed3b7de005e59ac3f24d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4ceadc46d7592ec254e09ad530390" id="r_adbc4ceadc46d7592ec254e09ad530390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a20be5a44c6ac697b8d6e6e4b4a578647">next_layer_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbc4ceadc46d7592ec254e09ad530390">next_layer</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:adbc4ceadc46d7592ec254e09ad530390"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:adbc4ceadc46d7592ec254e09ad530390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af7babaf0af94e975ed89b330ec1238" id="r_a3af7babaf0af94e975ed89b330ec1238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a20be5a44c6ac697b8d6e6e4b4a578647">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3af7babaf0af94e975ed89b330ec1238">next_layer</a> ()</td></tr>
<tr class="memdesc:a3af7babaf0af94e975ed89b330ec1238"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_layer getter  <br /></td></tr>
<tr class="separator:a3af7babaf0af94e975ed89b330ec1238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74bdaa048b3736b863b1d6dd01db4f7" id="r_ac74bdaa048b3736b863b1d6dd01db4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac74bdaa048b3736b863b1d6dd01db4f7">lowest_layer</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:ac74bdaa048b3736b863b1d6dd01db4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:ac74bdaa048b3736b863b1d6dd01db4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd1634176909efd99570e7ccf8e7145" id="r_a9fd1634176909efd99570e7ccf8e7145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fd1634176909efd99570e7ccf8e7145">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a9fd1634176909efd99570e7ccf8e7145"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowest_layer getter  <br /></td></tr>
<tr class="separator:a9fd1634176909efd99570e7ccf8e7145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48e23bfba52bb9938a7d24f2112296c" id="r_af48e23bfba52bb9938a7d24f2112296c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af48e23bfba52bb9938a7d24f2112296c">set_auto_pub_response</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:af48e23bfba52bb9938a7d24f2112296c"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto publish response setter. Should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call.  <br /></td></tr>
<tr class="separator:af48e23bfba52bb9938a7d24f2112296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7f4f653920a8139c907caefc764193" id="r_a8a7f4f653920a8139c907caefc764193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a7f4f653920a8139c907caefc764193">set_auto_ping_response</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:a8a7f4f653920a8139c907caefc764193"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto pingreq response setter. Should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call.  <br /></td></tr>
<tr class="separator:a8a7f4f653920a8139c907caefc764193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d9a07631f25da27b38ea68b8bee51d" id="r_af5d9a07631f25da27b38ea68b8bee51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d9a07631f25da27b38ea68b8bee51d">set_auto_map_topic_alias_send</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:af5d9a07631f25da27b38ea68b8bee51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:af5d9a07631f25da27b38ea68b8bee51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac722133ae56dc6cf8a247440d6c15e09" id="r_ac722133ae56dc6cf8a247440d6c15e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac722133ae56dc6cf8a247440d6c15e09">set_auto_replace_topic_alias_send</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:ac722133ae56dc6cf8a247440d6c15e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:ac722133ae56dc6cf8a247440d6c15e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33de735f6ac4f8aa9fbca3f120c38ac0" id="r_a33de735f6ac4f8aa9fbca3f120c38ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33de735f6ac4f8aa9fbca3f120c38ac0">set_pingresp_recv_timeout_ms</a> (std::size_t <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">ms</a>)</td></tr>
<tr class="memdesc:a33de735f6ac4f8aa9fbca3f120c38ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code disconnect_reason_code::keep_alive_timeout automatically before underlying layer is closed. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:a33de735f6ac4f8aa9fbca3f120c38ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5d8951ecd0480eceaf43b6a5b2b674" id="r_a9c5d8951ecd0480eceaf43b6a5b2b674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5d8951ecd0480eceaf43b6a5b2b674">set_bulk_write</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> val)</td></tr>
<tr class="memdesc:a9c5d8951ecd0480eceaf43b6a5b2b674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bulk write mode. If true, then concatenate multiple packets' const buffer sequence when <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> is called before the previous <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> is not completed. Otherwise, send packet one by one. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call.  <br /></td></tr>
<tr class="separator:a9c5d8951ecd0480eceaf43b6a5b2b674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b87ddeb98737b9c8a0e357f3b99632" id="r_a49b87ddeb98737b9c8a0e357f3b99632"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a49b87ddeb98737b9c8a0e357f3b99632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49b87ddeb98737b9c8a0e357f3b99632">acquire_unique_packet_id</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a49b87ddeb98737b9c8a0e357f3b99632"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:a49b87ddeb98737b9c8a0e357f3b99632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e9b3ffce05e5728ab56c205c9810e" id="r_a9e4e9b3ffce05e5728ab56c205c9810e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a9e4e9b3ffce05e5728ab56c205c9810e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e4e9b3ffce05e5728ab56c205c9810e">acquire_unique_packet_id_wait_until</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a9e4e9b3ffce05e5728ab56c205c9810e"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id. If packet_id is fully acquired, then wait until released.  <br /></td></tr>
<tr class="separator:a9e4e9b3ffce05e5728ab56c205c9810e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa074c0e8aae73b167b76a2a232d33da0" id="r_aa074c0e8aae73b167b76a2a232d33da0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:aa074c0e8aae73b167b76a2a232d33da0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa074c0e8aae73b167b76a2a232d33da0">register_packet_id</a> (<a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> packet_id, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:aa074c0e8aae73b167b76a2a232d33da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:aa074c0e8aae73b167b76a2a232d33da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbf4099a179a1d2c32410345b39fe7" id="r_a19cbf4099a179a1d2c32410345b39fe7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a19cbf4099a179a1d2c32410345b39fe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19cbf4099a179a1d2c32410345b39fe7">release_packet_id</a> (<a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> packet_id, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a19cbf4099a179a1d2c32410345b39fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:a19cbf4099a179a1d2c32410345b39fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472d7f318e9c576c364d148c817d6598" id="r_a472d7f318e9c576c364d148c817d6598"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a> , <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a472d7f318e9c576c364d148c817d6598"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a472d7f318e9c576c364d148c817d6598">send</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a> packet, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a472d7f318e9c576c364d148c817d6598"><td class="mdescLeft">&#160;</td><td class="mdescRight">send packet users can call <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> before the previous <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>'s CompletionToken is invoked  <br /></td></tr>
<tr class="separator:a472d7f318e9c576c364d148c817d6598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0ad1e5c8b1a748160b3445583845c1" id="r_aec0ad1e5c8b1a748160b3445583845c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:aec0ad1e5c8b1a748160b3445583845c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1">recv</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:aec0ad1e5c8b1a748160b3445583845c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked  <br /></td></tr>
<tr class="separator:aec0ad1e5c8b1a748160b3445583845c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd2f9f72b01b4497404072a537f2773" id="r_a3dd2f9f72b01b4497404072a537f2773"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a3dd2f9f72b01b4497404072a537f2773"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3dd2f9f72b01b4497404072a537f2773">recv</a> (std::set&lt; control_packet_type &gt; types, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a3dd2f9f72b01b4497404072a537f2773"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked.  <br /></td></tr>
<tr class="separator:a3dd2f9f72b01b4497404072a537f2773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed5921923e1644ec6bc8437f693143f" id="r_a0ed5921923e1644ec6bc8437f693143f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a0ed5921923e1644ec6bc8437f693143f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ed5921923e1644ec6bc8437f693143f">recv</a> (<a class="el" href="endpoint_8hpp.html#aed6ebca93cac28c67f2b4fb8641e775a">filter</a> fil, std::set&lt; control_packet_type &gt; types, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a0ed5921923e1644ec6bc8437f693143f"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive packet users CANNOT call <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. @params fil if <code>match</code> then matched types are targets. if <code>except</code> then not matched types are targets.  <br /></td></tr>
<tr class="separator:a0ed5921923e1644ec6bc8437f693143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72de2b77491d3aacad456a215d5c5937" id="r_a72de2b77491d3aacad456a215d5c5937"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a72de2b77491d3aacad456a215d5c5937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72de2b77491d3aacad456a215d5c5937">close</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a72de2b77491d3aacad456a215d5c5937"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the underlying connection  <br /></td></tr>
<tr class="separator:a72de2b77491d3aacad456a215d5c5937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eae263bd6e1eb3901dbee05088d6a8" id="r_a08eae263bd6e1eb3901dbee05088d6a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a08eae263bd6e1eb3901dbee05088d6a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08eae263bd6e1eb3901dbee05088d6a8">restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt; pvs, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>)</td></tr>
<tr class="memdesc:a08eae263bd6e1eb3901dbee05088d6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:a08eae263bd6e1eb3901dbee05088d6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d766a6d54b191c050073b20f746d2" id="r_a989d766a6d54b191c050073b20f746d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </td></tr>
<tr class="memitem:a989d766a6d54b191c050073b20f746d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a989d766a6d54b191c050073b20f746d2">get_stored_packets</a> (<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">token</a>) <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a989d766a6d54b191c050073b20f746d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets sotred packets mean inflight packets.  <br /></td></tr>
<tr class="separator:a989d766a6d54b191c050073b20f746d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f43d8cdb723fea82a2b0b8a37e5953" id="r_af0f43d8cdb723fea82a2b0b8a37e5953"><td class="memItemLeft" align="right" valign="top">optional&lt; <a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0f43d8cdb723fea82a2b0b8a37e5953">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:af0f43d8cdb723fea82a2b0b8a37e5953"><td class="mdescLeft">&#160;</td><td class="mdescRight">acuire unique packet_id.  <br /></td></tr>
<tr class="separator:af0f43d8cdb723fea82a2b0b8a37e5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d7bdefdbcfe71c7fa1ce40cbc583b6" id="r_a69d7bdefdbcfe71c7fa1ce40cbc583b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69d7bdefdbcfe71c7fa1ce40cbc583b6">register_packet_id</a> (<a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> pid)</td></tr>
<tr class="memdesc:a69d7bdefdbcfe71c7fa1ce40cbc583b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">register packet_id.  <br /></td></tr>
<tr class="separator:a69d7bdefdbcfe71c7fa1ce40cbc583b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bd0f62e5f5e27cb715e37b47b6b754" id="r_a23bd0f62e5f5e27cb715e37b47b6b754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23bd0f62e5f5e27cb715e37b47b6b754">release_packet_id</a> (<a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> pid)</td></tr>
<tr class="memdesc:a23bd0f62e5f5e27cb715e37b47b6b754"><td class="mdescLeft">&#160;</td><td class="mdescRight">release packet_id.  <br /></td></tr>
<tr class="separator:a23bd0f62e5f5e27cb715e37b47b6b754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4373b14f01a1954780a55fa108618734" id="r_a4373b14f01a1954780a55fa108618734"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4373b14f01a1954780a55fa108618734">get_qos2_publish_handled_pids</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a4373b14f01a1954780a55fa108618734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get processed but not released QoS2 packet ids This function should be called after disconnection.  <br /></td></tr>
<tr class="separator:a4373b14f01a1954780a55fa108618734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a9e9c6a92f5cb72c87de37bb58ae94" id="r_a78a9e9c6a92f5cb72c87de37bb58ae94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78a9e9c6a92f5cb72c87de37bb58ae94">restore_qos2_publish_handled_pids</a> (std::set&lt; <a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">pids</a>)</td></tr>
<tr class="memdesc:a78a9e9c6a92f5cb72c87de37bb58ae94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore processed but not released QoS2 packet ids This function should be called before receive the first publish.  <br /></td></tr>
<tr class="separator:a78a9e9c6a92f5cb72c87de37bb58ae94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60e7fe678e7844c33cd45fed8db028c" id="r_ae60e7fe678e7844c33cd45fed8db028c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae60e7fe678e7844c33cd45fed8db028c">restore_packets</a> (std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt; pvs)</td></tr>
<tr class="memdesc:ae60e7fe678e7844c33cd45fed8db028c"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore packets the restored packets would automatically send when CONNACK packet is received  <br /></td></tr>
<tr class="separator:ae60e7fe678e7844c33cd45fed8db028c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205376516c6337bfb5bbff9c04747de7" id="r_a205376516c6337bfb5bbff9c04747de7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a205376516c6337bfb5bbff9c04747de7">get_stored_packets</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a205376516c6337bfb5bbff9c04747de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stored packets sotred packets mean inflight packets.  <br /></td></tr>
<tr class="separator:a205376516c6337bfb5bbff9c04747de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501a5d70d41e7e019bdd606ed0885cef" id="r_a501a5d70d41e7e019bdd606ed0885cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a501a5d70d41e7e019bdd606ed0885cef">get_protocol_version</a> () <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a501a5d70d41e7e019bdd606ed0885cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MQTT protocol version  <br /></td></tr>
<tr class="separator:a501a5d70d41e7e019bdd606ed0885cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0921ea9afc8294df7ad6516eb7c258" id="r_a7c0921ea9afc8294df7ad6516eb7c258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0921ea9afc8294df7ad6516eb7c258">is_publish_processing</a> (<a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> pid) <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:a7c0921ea9afc8294df7ad6516eb7c258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MQTT PUBLISH packet processing status.  <br /></td></tr>
<tr class="separator:a7c0921ea9afc8294df7ad6516eb7c258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab379a92c9b5839a9cd8f48f1088b21f2" id="r_ab379a92c9b5839a9cd8f48f1088b21f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab379a92c9b5839a9cd8f48f1088b21f2">regulate_for_store</a> (v5::basic_publish_packet&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &amp;packet) <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a></td></tr>
<tr class="memdesc:ab379a92c9b5839a9cd8f48f1088b21f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regulate publish packet for store If topic is empty, extract topic from topic alias, and remove topic alias Otherwise, remove topic alias if exists.  <br /></td></tr>
<tr class="separator:ab379a92c9b5839a9cd8f48f1088b21f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a25eea2b21f25ccddc2bc5a8de0b08d47" id="r_a25eea2b21f25ccddc2bc5a8de0b08d47"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a25eea2b21f25ccddc2bc5a8de0b08d47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">static</a> std::shared_ptr&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">this_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25eea2b21f25ccddc2bc5a8de0b08d47">create</a> (<a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">ver</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Args</a> &amp;&amp;... <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">args</a>)</td></tr>
<tr class="memdesc:a25eea2b21f25ccddc2bc5a8de0b08d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">create  <br /></td></tr>
<tr class="separator:a25eea2b21f25ccddc2bc5a8de0b08d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab75c620f4e6eaf9e926d76fbda832011" id="r_ab75c620f4e6eaf9e926d76fbda832011"><td class="memItemLeft" align="right" valign="top"><a id="ab75c620f4e6eaf9e926d76fbda832011" name="ab75c620f4e6eaf9e926d76fbda832011"></a>
<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">static</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">constexpr</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>packet_id_bytes</b> = <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a></td></tr>
<tr class="memdesc:ab75c620f4e6eaf9e926d76fbda832011"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value given as PacketIdBytes. <br /></td></tr>
<tr class="separator:ab75c620f4e6eaf9e926d76fbda832011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:af3c69b0590e773ada1b40d8a48901acd" id="r_af3c69b0590e773ada1b40d8a48901acd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </td></tr>
<tr class="memitem:af3c69b0590e773ada1b40d8a48901acd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3c69b0590e773ada1b40d8a48901acd">endpoint</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, 2, as::strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;</td></tr>
<tr class="memdesc:af3c69b0590e773ada1b40d8a48901acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2, Strand=boost::asio::strand). This is for typical usecase.  <br /></td></tr>
<tr class="separator:af3c69b0590e773ada1b40d8a48901acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a14929f8b506ff8af125eb6c4c3966" id="r_a91a14929f8b506ff8af125eb6c4c3966"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </td></tr>
<tr class="memitem:a91a14929f8b506ff8af125eb6c4c3966"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91a14929f8b506ff8af125eb6c4c3966">endpoint_st</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, 2, null_strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;</td></tr>
<tr class="memdesc:a91a14929f8b506ff8af125eb6c4c3966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2, Strand=null_strand). This is only for single threaded environment.  <br /></td></tr>
<tr class="separator:a91a14929f8b506ff8af125eb6c4c3966"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;<br />
class async_mqtt::basic_endpoint&lt; Role, PacketIdBytes, Strand, NextLayer &gt;</div><p>MQTT endpoint corresponding to the connection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">PacketIdBytes</td><td>MQTT spec is 2. You can use <code>endpoint</code> for that. </td></tr>
    <tr><td class="paramname">Strand</td><td>strand class template type. By default boost::asio::strand&lt;T&gt; should be used. You can replace it with null_strand if you run the endpoint on single thread environment. </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af0f43d8cdb723fea82a2b0b8a37e5953" name="af0f43d8cdb723fea82a2b0b8a37e5953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f43d8cdb723fea82a2b0b8a37e5953">&#9670;&#160;</a></span>acquire_unique_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;packet_id_t&gt; if acquired return acquired packet id, otherwise nullopt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a49b87ddeb98737b9c8a0e357f3b99632" name="a49b87ddeb98737b9c8a0e357f3b99632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b87ddeb98737b9c8a0e357f3b99632">&#9670;&#160;</a></span>acquire_unique_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is optional&lt;packet_id_t&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a9e4e9b3ffce05e5728ab56c205c9810e" name="a9e4e9b3ffce05e5728ab56c205c9810e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e9b3ffce05e5728ab56c205c9810e">&#9670;&#160;</a></span>acquire_unique_packet_id_wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::acquire_unique_packet_id_wait_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>acuire unique packet_id. If packet_id is fully acquired, then wait until released. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is packet_id_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a72de2b77491d3aacad456a215d5c5937" name="a72de2b77491d3aacad456a215d5c5937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72de2b77491d3aacad456a215d5c5937">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>close the underlying connection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a25eea2b21f25ccddc2bc5a8de0b08d47" name="a25eea2b21f25ccddc2bc5a8de0b08d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25eea2b21f25ccddc2bc5a8de0b08d47">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">static</a> std::shared_ptr&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">this_type</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a></td>          <td class="paramname"><span class="paramname"><em>ver</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types for the next layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ver</td><td>MQTT protocol version client can set v5 or v3_1_1, in addition server can set undetermined </td></tr>
    <tr><td class="paramname">args</td><td>args for the next layer. There are predefined next layer types: <br  />
 <a class="el" href="predefined__underlying__layer_8hpp.html#af0fedc2324340e8a97a85d091e912983">protocol::mqtt</a>, <a class="el" href="predefined__underlying__layer_8hpp.html#ae84d125ae067aa02cb9f8965bbaed3f9">protocol::mqtts</a>, <a class="el" href="predefined__underlying__layer_8hpp.html#aa5faa493592170b84fe10807b67f2a7a">protocol::ws</a>, and <a class="el" href="predefined__underlying__layer_8hpp.html#a3f43ad7309eefaa8f5e4dde369e19212">protocol::wss</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared_ptr of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. </dd></dl>

</div>
</div>
<a id="a501a5d70d41e7e019bdd606ed0885cef" name="a501a5d70d41e7e019bdd606ed0885cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501a5d70d41e7e019bdd606ed0885cef">&#9670;&#160;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="protocol__version_8hpp.html#a133d6d106d4e527d07fea2d12544c0c0">protocol_version</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get MQTT protocol version </p>
<dl class="section return"><dt>Returns</dt><dd>MQTT protocol version </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a4373b14f01a1954780a55fa108618734" name="a4373b14f01a1954780a55fa108618734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4373b14f01a1954780a55fa108618734">&#9670;&#160;</a></span>get_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get processed but not released QoS2 packet ids This function should be called after disconnection. </p>
<dl class="section return"><dt>Returns</dt><dd>set of packet_ids </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a205376516c6337bfb5bbff9c04747de7" name="a205376516c6337bfb5bbff9c04747de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205376516c6337bfb5bbff9c04747de7">&#9670;&#160;</a></span>get_stored_packets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_stored_packets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get stored packets sotred packets mean inflight packets. </p>
<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS1) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet <dl class="section return"><dt>Returns</dt><dd>std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a989d766a6d54b191c050073b20f746d2" name="a989d766a6d54b191c050073b20f746d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989d766a6d54b191c050073b20f746d2">&#9670;&#160;</a></span>get_stored_packets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::get_stored_packets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get stored packets sotred packets mean inflight packets. </p>
<ul>
<li>PUBLISH packet (QoS1) not received PUBACK packet</li>
<li>PUBLISH packet (QoS1) not received PUBREC packet</li>
<li>PUBREL packet not received PUBCOMP packet <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is std::vector&lt;basic_store_packet_variant&lt;PacketIdBytes&gt;&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a6010146d8beed3b7de005e59ac3f24d4" name="a6010146d8beed3b7de005e59ac3f24d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6010146d8beed3b7de005e59ac3f24d4">&#9670;&#160;</a></span>in_strand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::in_strand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand checker </p>
<dl class="section return"><dt>Returns</dt><dd>true if the current context running in the strand, otherwise false </dd></dl>

</div>
</div>
<a id="a7c0921ea9afc8294df7ad6516eb7c258" name="a7c0921ea9afc8294df7ad6516eb7c258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0921ea9afc8294df7ad6516eb7c258">&#9670;&#160;</a></span>is_publish_processing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::is_publish_processing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get MQTT PUBLISH packet processing status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>packet_id corresponding to the publish packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the packet is processing, then true, otherwise false. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a9fd1634176909efd99570e7ccf8e7145" name="a9fd1634176909efd99570e7ccf8e7145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd1634176909efd99570e7ccf8e7145">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="ac74bdaa048b3736b863b1d6dd01db4f7" name="ac74bdaa048b3736b863b1d6dd01db4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74bdaa048b3736b863b1d6dd01db4f7">&#9670;&#160;</a></span>lowest_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a>  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lowest_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the lowest_layer </dd></dl>

</div>
</div>
<a id="a3af7babaf0af94e975ed89b330ec1238" name="a3af7babaf0af94e975ed89b330ec1238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af7babaf0af94e975ed89b330ec1238">&#9670;&#160;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a20be5a44c6ac697b8d6e6e4b4a578647">next_layer_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the next_layer </dd></dl>

</div>
</div>
<a id="adbc4ceadc46d7592ec254e09ad530390" name="adbc4ceadc46d7592ec254e09ad530390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc4ceadc46d7592ec254e09ad530390">&#9670;&#160;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a20be5a44c6ac697b8d6e6e4b4a578647">next_layer_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a>  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next_layer getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the next_layer </dd></dl>

</div>
</div>
<a id="aec0ad1e5c8b1a748160b3445583845c1" name="aec0ad1e5c8b1a748160b3445583845c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0ad1e5c8b1a748160b3445583845c1">&#9670;&#160;</a></span>recv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a0ed5921923e1644ec6bc8437f693143f" name="a0ed5921923e1644ec6bc8437f693143f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed5921923e1644ec6bc8437f693143f">&#9670;&#160;</a></span>recv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#aed6ebca93cac28c67f2b4fb8641e775a">filter</a></td>          <td class="paramname"><span class="paramname"><em>fil</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; control_packet_type &gt;</td>          <td class="paramname"><span class="paramname"><em>types</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. @params fil if <code>match</code> then matched types are targets. if <code>except</code> then not matched types are targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a3dd2f9f72b01b4497404072a537f2773" name="a3dd2f9f72b01b4497404072a537f2773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd2f9f72b01b4497404072a537f2773">&#9670;&#160;</a></span>recv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; control_packet_type &gt;</td>          <td class="paramname"><span class="paramname"><em>types</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>receive packet users CANNOT call <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> before the previous <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a>'s CompletionToken is invoked if packet is not filterd, then next <a class="el" href="#aec0ad1e5c8b1a748160b3445583845c1" title="receive packet users CANNOT call recv() before the previous recv()&#39;s CompletionToken is invoked">recv()</a> starts automatically. if receive error happenes, then token would be invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>target control_packet_types </td></tr>
    <tr><td class="paramname">token</td><td>the param is packet_variant_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="aa074c0e8aae73b167b76a2a232d33da0" name="aa074c0e8aae73b167b76a2a232d33da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa074c0e8aae73b167b76a2a232d33da0">&#9670;&#160;</a></span>register_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>packet_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
    <tr><td class="paramname">token</td><td>the param is bool. If true, success, otherwise the packet_id has already been used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a69d7bdefdbcfe71c7fa1ce40cbc583b6" name="a69d7bdefdbcfe71c7fa1ce40cbc583b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d7bdefdbcfe71c7fa1ce40cbc583b6">&#9670;&#160;</a></span>register_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If true, success, otherwise the packet_id has already been used. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="ab379a92c9b5839a9cd8f48f1088b21f2" name="ab379a92c9b5839a9cd8f48f1088b21f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab379a92c9b5839a9cd8f48f1088b21f2">&#9670;&#160;</a></span>regulate_for_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::regulate_for_store </td>
          <td>(</td>
          <td class="paramtype">v5::basic_publish_packet&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regulate publish packet for store If topic is empty, extract topic from topic alias, and remove topic alias Otherwise, remove topic alias if exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to regulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a19cbf4099a179a1d2c32410345b39fe7" name="a19cbf4099a179a1d2c32410345b39fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cbf4099a179a1d2c32410345b39fe7">&#9670;&#160;</a></span>release_packet_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>packet_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a23bd0f62e5f5e27cb715e37b47b6b754" name="a23bd0f62e5f5e27cb715e37b47b6b754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bd0f62e5f5e27cb715e37b47b6b754">&#9670;&#160;</a></span>release_packet_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a></td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet_id to release </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="ae60e7fe678e7844c33cd45fed8db028c" name="ae60e7fe678e7844c33cd45fed8db028c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60e7fe678e7844c33cd45fed8db028c">&#9670;&#160;</a></span>restore_packets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>pvs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a08eae263bd6e1eb3901dbee05088d6a8" name="a08eae263bd6e1eb3901dbee05088d6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eae263bd6e1eb3901dbee05088d6a8">&#9670;&#160;</a></span>restore_packets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::restore_packets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classasync__mqtt_1_1basic__store__packet__variant.html">basic_store_packet_variant</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>pvs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore packets the restored packets would automatically send when CONNACK packet is received </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pvs</td><td>packets to restore </td></tr>
    <tr><td class="paramname">token</td><td>the param is void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="a78a9e9c6a92f5cb72c87de37bb58ae94" name="a78a9e9c6a92f5cb72c87de37bb58ae94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a9e9c6a92f5cb72c87de37bb58ae94">&#9670;&#160;</a></span>restore_qos2_publish_handled_pids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::restore_qos2_publish_handled_pids </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="#aa7ac549d8d2701f3aaa2fab51a44c7f1">packet_id_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pids</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore processed but not released QoS2 packet ids This function should be called before receive the first publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pids</td><td>packet ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is SYNC function that must only be called in the strand. </dd></dl>

</div>
</div>
<a id="a472d7f318e9c576c364d148c817d6598" name="a472d7f318e9c576c364d148c817d6598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472d7f318e9c576c364d148c817d6598">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a> , <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">auto</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Packet</a></td>          <td class="paramname"><span class="paramname"><em>packet</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">CompletionToken</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send packet users can call <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> before the previous <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>'s CompletionToken is invoked </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>packet to send </td></tr>
    <tr><td class="paramname">token</td><td>the param is <a class="el" href="structasync__mqtt_1_1system__error.html" title="async_mqtt error class. It is used as CompletionToken parameter and exception.">system_error</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deduced by token </dd></dl>

</div>
</div>
<a id="af5d9a07631f25da27b38ea68b8bee51d" name="af5d9a07631f25da27b38ea68b8bee51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d9a07631f25da27b38ea68b8bee51d">&#9670;&#160;</a></span>set_auto_map_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_map_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto map (allocate) topic alias on send PUBLISH packet. If all topic aliases are used, then overwrite by LRU algorithm. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically mapping. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto mapping, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a7f4f653920a8139c907caefc764193" name="a8a7f4f653920a8139c907caefc764193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7f4f653920a8139c907caefc764193">&#9670;&#160;</a></span>set_auto_ping_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_ping_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto pingreq response setter. Should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af48e23bfba52bb9938a7d24f2112296c" name="af48e23bfba52bb9938a7d24f2112296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48e23bfba52bb9938a7d24f2112296c">&#9670;&#160;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto publish response setter. Should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a>/recv() call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically sending. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, puback, pubrec, pubrel, and pubcomp are automatically sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac722133ae56dc6cf8a247440d6c15e09" name="ac722133ae56dc6cf8a247440d6c15e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac722133ae56dc6cf8a247440d6c15e09">&#9670;&#160;</a></span>set_auto_replace_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_auto_replace_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>auto replace topic with corresponding topic alias on send PUBLISH packet. Registering topic alias need to do manually. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default not automatically replacing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable auto replacing, otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c5d8951ecd0480eceaf43b6a5b2b674" name="a9c5d8951ecd0480eceaf43b6a5b2b674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5d8951ecd0480eceaf43b6a5b2b674">&#9670;&#160;</a></span>set_bulk_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_bulk_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bulk write mode. If true, then concatenate multiple packets' const buffer sequence when <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> is called before the previous <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> is not completed. Otherwise, send packet one by one. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default bulk write mode is false (disabled) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if true, enable bulk write mode, otherwise disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33de735f6ac4f8aa9fbca3f120c38ac0" name="a33de735f6ac4f8aa9fbca3f120c38ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33de735f6ac4f8aa9fbca3f120c38ac0">&#9670;&#160;</a></span>set_pingresp_recv_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">void</a> <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::set_pingresp_recv_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set timeout for receiving PINGRESP packet after PINGREQ packet is sent. If the timer is fired, then the underlying layer is closed from the client side. If the protocol_version is v5, then send DISCONNECT packet with the reason code disconnect_reason_code::keep_alive_timeout automatically before underlying layer is closed. <br  />
 This function should be called before <a class="el" href="#a472d7f318e9c576c364d148c817d6598" title="send packet users can call send() before the previous send()&#39;s CompletionToken is invoked">send()</a> call. </p>
<dl class="section note"><dt>Note</dt><dd>By default timeout is not set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>if 0, timer is not set, otherwise set val milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35a6bbeb0124a2ccf2b746bd5c8e6039" name="a35a6bbeb0124a2ccf2b746bd5c8e6039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a6bbeb0124a2ccf2b746bd5c8e6039">&#9670;&#160;</a></span>strand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9e9d540dac0d5efa243c5f6f7c17e42">strand_type</a> &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::strand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand getter </p>
<dl class="section return"><dt>Returns</dt><dd>reference of the strand </dd></dl>

</div>
</div>
<a id="a8f523ba7d97ab371165c62fa954f6dab" name="a8f523ba7d97ab371165c62fa954f6dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f523ba7d97ab371165c62fa954f6dab">&#9670;&#160;</a></span>strand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9e9d540dac0d5efa243c5f6f7c17e42">strand_type</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">const</a>  &amp; <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">async_mqtt::basic_endpoint</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">PacketIdBytes</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Strand</a>, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt;::strand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>strand getter </p>
<dl class="section return"><dt>Returns</dt><dd>const reference of the strand </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="af3c69b0590e773ada1b40d8a48901acd" name="af3c69b0590e773ada1b40d8a48901acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c69b0590e773ada1b40d8a48901acd">&#9670;&#160;</a></span>endpoint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a> <a class="el" href="#af3c69b0590e773ada1b40d8a48901acd">endpoint</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, 2, as::strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2, Strand=boost::asio::strand). This is for typical usecase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91a14929f8b506ff8af125eb6c4c3966" name="a91a14929f8b506ff8af125eb6c4c3966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a14929f8b506ff8af125eb6c4c3966">&#9670;&#160;</a></span>endpoint_st</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, std::size_t PacketIdBytes, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">template</a>&lt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> &gt; <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> Strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="endpoint_8hpp.html#a83492944f4f6b69eb11ce917d1f27c4a">role</a> Role, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">typename</a> <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">using</a> <a class="el" href="#a91a14929f8b506ff8af125eb6c4c3966">endpoint_st</a> = <a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a>&lt;<a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">Role</a>, 2, null_strand, <a class="el" href="classasync__mqtt_1_1basic__packet__variant.html">NextLayer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type alias of <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a> (PacketIdBytes=2, Strand=null_strand). This is only for single threaded environment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Role</td><td>role for packet sendable checking </td></tr>
    <tr><td class="paramname">NextLayer</td><td>Just next layer for <a class="el" href="classasync__mqtt_1_1basic__endpoint.html" title="MQTT endpoint corresponding to the connection.">basic_endpoint</a>. mqtt, mqtts, ws, and wss are predefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/async_mqtt/include/async_mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>async_mqtt</b></li><li class="navelem"><a class="el" href="classasync__mqtt_1_1basic__endpoint.html">basic_endpoint</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
