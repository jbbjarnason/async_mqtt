:last-update-label!:
:am-version: latest
:source-highlighter: rouge
:rouge-style: base16.monokai

ifdef::env-github[:am-base-path: ../../main]
ifndef::env-github[:am-base-path: ../..]
ifdef::env-github[:api-base: link:https://redboltz.github.io/async_mqtt/doc/{am-version}/html]
ifndef::env-github[:api-base: link:../api]

= Thread safety

== Single threaded

You can call both async APIs and sync APIs without any special care required.

== Multi threded

All distinct objects are thread unsafe. To access shared `client` and/or `endpoint`, you can construct it with strand wrapped executor for the underlying layer's argument. `client` and `endpoint` `async_*` member functions dispatch to the executor. As the result of the strand effect, your asynchronous process is serialized.

The following synchronous member functions is directly accessed. So you need to introduce the locks or explicit dispatching to the executor.



= Thread Safety

== Single Threaded

You can call both asynchronous (async) and synchronous (sync) APIs without any special precautions.

== Multi-threaded

All distinct objects are not thread-safe. To access shared `client` and/or `endpoint` objects, construct them with a strand-wrapped executor for the underlying layer's argument. The `async_*` member functions of `client` and `endpoint` will dispatch to the executor. As a result of the strand's effect, your asynchronous processes will be serialized.

The following synchronous member functions are accessed directly. Therefore, you need to introduce locks or explicitly dispatch to the executor.


|===
|endpoint member function | effects

|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#a9864c9c46f655e82a8cbb93d2725f0e0++[acquire_unique_packet_id]|Acquire the new unique packet_id
|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#adaff45fdd6e9bc61001b1ac936040c01++[register_packet_id]|Register the packet_id
|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#ae72fa838272da0e140e5ad1acf24463b++[release_packet_id]|Release the packet_id
|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#a5c54a4deadb8706eafe3f56fc59eca07++[get_qos2_publish_handled_pids]|Get already PUBLISH recv CompletionToken is invoked packet_ids
|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#abcfa56073b24d3efa6c8ed881295e45e++[restore_qos2_publish_handled_pids]|Restore already PUBLISH recv CompletionToken is invoked packet_ids
|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#a6dfe47bd9ab1590e66f110e3dbe1087e++[restore_packets]|Restore pacets as stored packets
|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#a5ed8d45ffcfb114533d8de5ddddb4f92++[get_stored_packets]|Get stored packets
|{api-base}/++classasync__mqtt_1_1basic__endpoint.html#a9cbabd5f427b1cb18d61ac49c7bbf83b++[get_protocol_version]|Get MQTT protocol version
|===

|===
|client member function | effects

|{api-base}/++classasync__mqtt_1_1client.html#ab160ebb19bd7e51f8460e59a88deff86++[acquire_unique_packet_id]|Acquire the new unique packet_id
|{api-base}/++classasync__mqtt_1_1client.html#a2a7414f348afda7a9059135338ddaadc++[register_packet_id]|Register the packet_id
|{api-base}/++classasync__mqtt_1_1client.html#a5e091785f9ed21afc1aeaf9a09ccebb2++[release_packet_id]|Release the packet_id
|===
