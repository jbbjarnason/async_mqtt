:last-update-label!:
:am-version: latest
:source-highlighter: rouge
:rouge-style: base16.monokai

ifdef::env-github[:am-base-path: ../../main]
ifndef::env-github[:am-base-path: ../..]
ifdef::env-github[:api-base: link:https://redboltz.github.io/async_mqtt/doc/{am-version}/html]
ifndef::env-github[:api-base: link:../api]

= Client

== Create client
First, choose MQTT protocol version (v3.1.1 or v5), and then choose underlying layer.

ifdef::env-github[image::../img/layer.svg[layer structure]]
ifndef::env-github[image::layer.svg[layer structure]]

== mqtt

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::client<am::protocol_version::v3_1_1, am::protocol::mqtt> amcl{
        ioc.get_executor() // args for underlying layer (mqtt)
        // mqtt is as::basic_stream_socket<as::ip::tcp, as::io_context::executor_type>
    );
```

== mqtts

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    am::client<am::protocol_version::v5, am::protocol::mqtts> amcl{
        ioc.get_executor(),  // args for underlying layer (as::ssl::stream<mqtt>)
        ctx
    );
```

NOTE: `tls` is namespace alias of `boost::asio::ssl` by default.

== ws

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::client<am::protocol_version::v3_1_1, am::protocol::ws> amcl{
    auto amep = am::endpoint<am::role::client, am::protocol::ws>::create(
        ioc.get_executor()  // args for underlying layer (bs::websocket::stream<mqtt>)
    );
```


== wss

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    am::client<am::protocol_version::v3_1_1, am::protocol::wss> amcl{
        ioc.get_executor(),  // args for underlying layer ( bs::websocket::stream<mqtts>)
        ctx                  // mqtts is as::ssl::stream<mqtt>
    );
```

== Layer access

|===
|Layer access | mqtt | mqtts | ws | wss

|next_layer()|TCP stream|TLS stream| WS stream | WS stream
|next_layer().next_layer()|-|TCP stream|TCP stream | TLS stream
|next_layer().next_layer().next_layer()|-|-|-|TCP stream
|lowest_layer()|TCP stream|TCP stream|TCP stream|TCP stream
|===

== Handshaking underlying layer

You can use underlying handshaking functions as follows:

```cpp
// Underlying TCP connect
co_await as::async_connect(
    amcl.next_layer(),
    eps,
    as::use_awaitable
);
std::cout << "TCP connected" << std::endl;
```

Similarly, handshake TLS, WebSocket layers if needed.

== Send MQTT CONNECT packet and start receive loop

After underlying layers' handshaking is completed, then start MQTT layer connection.

=== {api-base}/++classasync__mqtt_1_1basic__client.html#a64c2b201c643fabc568865933b681f80++[start()] funtion

```cpp
// MQTT connect and receive loop start
auto connack_opt = co_await amcl.start(
    am::v5::connect_packet{
        true,   // clean_session
        0x1234, // keep_alive
        am::allocate_buffer("cid1"),
        am::nullopt, // will
        am::nullopt, // username set like allocate_buffer("user1"),
        am::nullopt  // password set like allocate_buffer("pass1")
    },
    as::use_awaitable
);
if (connack_opt) {
    std::cout << *connack_opt << std::endl;
}
```

CompletionToken parameters are error_code and connack_packet (optional). connack_packet has a value only if error_code is success. When you use CompletionToken such as `as::use_awaitable`, `as::use_future`, `as::deferred`, the first error_code is converted to exception. If you want to have the error_code as the return value, you can do as follows:

```cpp
// MQTT connect and receive loop start
auto [ec, connack_opt] = co_await amcl.start(
    am::v5::connect_packet{
        true,   // clean_session
        0x1234, // keep_alive
        am::allocate_buffer("cid1"),
        am::nullopt, // will
        am::nullopt, // username set like allocate_buffer("user1"),
        am::nullopt  // password set like allocate_buffer("pass1")
    },
    as::as_tuple(as::use_awaitable)
);
std::cout << ec.message() << std::endl;
if (connack_opt) {
    std::cout << *connack_opt << std::endl;
}
```

== Send MQTT SUBSCRIBE/UNSUBSCRIBE and wait SUBACK/UNSUBACK

=== {api-base}/++classasync__mqtt_1_1basic__client.html#ae74159d835dca15f87b760b53acb4d51++[subscribe()] funtion

```cpp
// subscribe
// MQTT send subscribe and wait suback
std::vector<am::topic_subopts> sub_entry{
    {am::allocate_buffer("topic1"), am::qos::at_most_once},
    {am::allocate_buffer("topic2"), am::qos::at_least_once},
    {am::allocate_buffer("topic3"), am::qos::exactly_once},
};
auto suback_opt = co_await amcl.subscribe(
    am::v5::subscribe_packet{
        *amcl.acquire_unique_packet_id(), // sync version only in strand
        am::force_move(sub_entry) // sub_entry variable is required to avoid g++ bug
    },
    as::use_awaitable
);
if (suback_opt) {
    std::cout << *suback_opt << std::endl;
}
```

CompletionToken parameters are error_code and suback_packet (optional). suback_packet has a value only if error_code is success.

=== {api-base}/++classasync__mqtt_1_1basic__client.html#a0ff1b5b724340a3df4c9ce9fab7a4b90++[unsubscribe()] funtion

```cpp
// MQTT send unsubscribe and wait unsuback
std::vector<am::topic_sharename> unsub_entry{
    {am::allocate_buffer("topic1")},
    {am::allocate_buffer("topic2")},
    {am::allocate_buffer("topic3")},
};

auto unsuback_opt = co_await amcl.unsubscribe(
    am::v5::unsubscribe_packet{
        *amcl.acquire_unique_packet_id(), // sync version only in strand
        am::force_move(unsub_entry) // unsub_entry variable is required to avoid g++ bug
    },
    as::use_awaitable
);
if (unsuback_opt) {
    std::cout << *unsuback_opt << std::endl;
}
```

CompletionToken parameters are error_code and unsuback_packet (optional). unsuback_packet has a value only if error_code is success.

== Send PUBLISH packet and wait response

=== {api-base}/++classasync__mqtt_1_1basic__client.html#ab6bed9cb83ac66b7bcb8595941edae4c++[publish()] funtion

Here is a code example that sending QoS0 PUBLISH packet.

```cpp
// MQTT publish QoS0 and wait response (socket write complete)
auto pubres0 = co_await amcl.publish(
    am::v5::publish_packet{
        am::allocate_buffer("topic1"),
        am::allocate_buffer("payload1"),
        am::qos::at_most_once
    },
    as::use_awaitable
);
```

CompletionToken parameters are error_code and {api-base}/++structasync__mqtt_1_1basic__client_1_1pubres__t.html++[pubres_t].
When you send QoS0 PUBLISH packet, no response packet is expected, so the CompletionToken is invoked when underlying layer's async_write operation is finished.
All the members of pubres_t are nullopt.

Here is a code example that sending QoS1 PUBLISH packet.

```cpp
// MQTT publish QoS1 and wait response (puback receive)
auto pid_pub1_opt = co_await amcl.acquire_unique_packet_id(as::use_awaitable); // async version
auto pubres1 = co_await amcl.publish(
    am::v5::publish_packet{
        *pid_pub1_opt,
        am::allocate_buffer("topic2"),
        am::allocate_buffer("payload2"),
        am::qos::at_least_once
    },
    as::use_awaitable
);
```

In order to create QoS1 PUBLISH packet, you need to acquire packet identifier. The example code above uses {api-base}/++classasync__mqtt_1_1basic__client.html#aa5a37f75664bb4dd8b883e464f2016e5++[acquire_unique_packet_id()]. This is asynchnorous version. You can call it form anywhere you want. If all packet id is acquired, the CompletionToken parameter is nullopt. For convenience, sync version {api-base}/++classasync__mqtt_1_1basic__client.html#acaea92142dca0924af36e5acef91d8bb++[acquire_unique_packet_id()] exists. When you use callback function approach, it could help keep the code simple.







== Receive PUBLISH packet from the broker

== Whole code

* xref:{am-base-path}/example/cl_cpp20coro_mqtt.cpp[cl_cpp20coro_mqtt.cpp]


