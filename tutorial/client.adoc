:last-update-label!:
:nofooter:
:am-version: latest
:source-highlighter: rouge
:rouge-style: base16.monokai

ifdef::env-github[:am-base-path: ../../main]
ifndef::env-github[:am-base-path: ../..]
ifdef::env-github[:api-base: link:https://redboltz.github.io/async_mqtt/doc/{am-version}/html]
ifndef::env-github[:api-base: link:../api]

= Client

== Create client
First, choose MQTT protocol version (v3.1.1 or v5), and then choose underlying layer.

ifdef::env-github[image::../img/layer.svg[layer structure]]
ifndef::env-github[image::layer.svg[layer structure]]

== mqtt

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::client<am::protocol_version::v3_1_1, am::protocol::mqtt> amcl{
        ioc.get_executor() // args for underlying layer (mqtt)
        // mqtt is as::basic_stream_socket<as::ip::tcp, as::io_context::executor_type>
    );
```

== mqtts

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    am::client<am::protocol_version::v5, am::protocol::mqtts> amcl{
        ioc.get_executor(),  // args for underlying layer (as::ssl::stream<mqtt>)
        ctx
    );
```

NOTE: `tls` is namespace alias of `boost::asio::ssl` by default.

== ws

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::client<am::protocol_version::v3_1_1, am::protocol::ws> amcl{
    auto amep = am::endpoint<am::role::client, am::protocol::ws>::create(
        ioc.get_executor()  // args for underlying layer (bs::websocket::stream<mqtt>)
    );
```


== wss

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    am::client<am::protocol_version::v3_1_1, am::protocol::wss> amcl{
        ioc.get_executor(),  // args for underlying layer ( bs::websocket::stream<mqtts>)
        ctx                  // mqtts is as::ssl::stream<mqtt>
    );
```

== Layer access

|===
|Layer access | mqtt | mqtts | ws | wss

|next_layer()|TCP stream|TLS stream| WS stream | WS stream
|next_layer().next_layer()|-|TCP stream|TCP stream | TLS stream
|next_layer().next_layer().next_layer()|-|-|-|TCP stream
|lowest_layer()|TCP stream|TCP stream|TCP stream|TCP stream
|===

== Handshaking underlying layer

You can use underlying handshaking functions as follows:

```cpp
// Underlying TCP connect
co_await as::async_connect(
    amcl.next_layer(),
    eps,
    as::use_awaitable
);
std::cout << "TCP connected" << std::endl;
```

Similarly, handshake TLS, WebSocket layers if needed.

== Send MQTT CONNECT packet and start receive loop

After underlying layers' handshaking is completed, then start MQTT layer connection.

=== {api-base}/++classasync__mqtt_1_1basic__client.html#a64c2b201c643fabc568865933b681f80++[start()] funtion

```cpp
// MQTT connect and receive loop start
auto connack_opt = co_await amcl.start(
    am::v5::connect_packet{
        true,   // clean_session
        0x1234, // keep_alive
        am::allocate_buffer("cid1"),
        am::nullopt, // will
        am::nullopt, // username set like allocate_buffer("user1"),
        am::nullopt  // password set like allocate_buffer("pass1")
    },
    as::use_awaitable
);
if (connack_opt) {
    std::cout << *connack_opt << std::endl;
}
```

CompletionToken parameters are error_code and connack_packet (optional). connack_packet has a value only if error_code is success. When you use CompletionToken such as `as::use_awaitable`, `as::use_future`, `as::deferred`, the first error_code is converted to exception. If you want to have the error_code as the return value, you can do as follows:

```cpp
// MQTT connect and receive loop start
auto [ec, connack_opt] = co_await amcl.start(
    am::v5::connect_packet{
        true,   // clean_session
        0x1234, // keep_alive
        am::allocate_buffer("cid1"),
        am::nullopt, // will
        am::nullopt, // username set like allocate_buffer("user1"),
        am::nullopt  // password set like allocate_buffer("pass1")
    },
    as::as_tuple(as::use_awaitable)
);
std::cout << ec.message() << std::endl;
if (connack_opt) {
    std::cout << *connack_opt << std::endl;
}
```

== Send SUBSCRIBE/UNSUBSCRIBE and wait SUBACK/UNSUBACK

=== {api-base}/++classasync__mqtt_1_1basic__client.html#ae74159d835dca15f87b760b53acb4d51++[subscribe()] funtion

```cpp
// subscribe
// MQTT send subscribe and wait suback
std::vector<am::topic_subopts> sub_entry{
    {am::allocate_buffer("topic1"), am::qos::at_most_once},
    {am::allocate_buffer("topic2"), am::qos::at_least_once},
    {am::allocate_buffer("topic3"), am::qos::exactly_once},
};
auto suback_opt = co_await amcl.subscribe(
    am::v5::subscribe_packet{
        *amcl.acquire_unique_packet_id(), // sync version only in strand
        am::force_move(sub_entry) // sub_entry variable is required to avoid g++ bug
    },
    as::use_awaitable
);
if (suback_opt) {
    std::cout << *suback_opt << std::endl;
}
```

CompletionToken parameters are error_code and suback_packet (optional). suback_packet has a value only if error_code is success.

=== {api-base}/++classasync__mqtt_1_1basic__client.html#a0ff1b5b724340a3df4c9ce9fab7a4b90++[unsubscribe()] funtion

```cpp
// MQTT send unsubscribe and wait unsuback
std::vector<am::topic_sharename> unsub_entry{
    {am::allocate_buffer("topic1")},
    {am::allocate_buffer("topic2")},
    {am::allocate_buffer("topic3")},
};

auto unsuback_opt = co_await amcl.unsubscribe(
    am::v5::unsubscribe_packet{
        *amcl.acquire_unique_packet_id(), // sync version only in strand
        am::force_move(unsub_entry) // unsub_entry variable is required to avoid g++ bug
    },
    as::use_awaitable
);
if (unsuback_opt) {
    std::cout << *unsuback_opt << std::endl;
}
```

CompletionToken parameters are error_code and unsuback_packet (optional). unsuback_packet has a value only if error_code is success.

== Send PUBLISH packet and wait response

=== {api-base}/++classasync__mqtt_1_1basic__client.html#ab6bed9cb83ac66b7bcb8595941edae4c++[publish()] funtion

Here is a code example that sending QoS0 PUBLISH packet.

```cpp
// MQTT publish QoS0 and wait response (socket write complete)
auto pubres0 = co_await amcl.publish(
    am::v5::publish_packet{
        am::allocate_buffer("topic1"),
        am::allocate_buffer("payload1"),
        am::qos::at_most_once
    },
    as::use_awaitable
);
```

CompletionToken parameters are error_code and {api-base}/++structasync__mqtt_1_1basic__client_1_1pubres__t.html++[pubres_t].
When you send QoS0 PUBLISH packet, no response packet is expected, so the CompletionToken is invoked when underlying layer's async_write operation is finished.
All the members of pubres_t are nullopt.

Here is a code example that sending QoS1 PUBLISH packet.

```cpp
// MQTT publish QoS1 and wait response (puback receive)
auto pid_pub1_opt = co_await amcl.acquire_unique_packet_id(as::use_awaitable); // async version
auto pubres1 = co_await amcl.publish(
    am::v5::publish_packet{
        *pid_pub1_opt,
        am::allocate_buffer("topic2"),
        am::allocate_buffer("payload2"),
        am::qos::at_least_once
    },
    as::use_awaitable
);
```

In order to create QoS1 PUBLISH packet, you need to acquire packet identifier. The example code above uses {api-base}/++classasync__mqtt_1_1basic__client.html#aa5a37f75664bb4dd8b883e464f2016e5++[acquire_unique_packet_id()]. This is asynchnorous version. You can call it form anywhere you want. If all packet id is acquired, the CompletionToken parameter is nullopt. For convenience, sync version {api-base}/++classasync__mqtt_1_1basic__client.html#acaea92142dca0924af36e5acef91d8bb++[acquire_unique_packet_id()] exists. When you use callback function approach, it could help keep the code simple. Sync version must be called in the client's strand. For example, anywhare in the callback function that is registered to client member functions as a CompletionToken(CompletionHandler).

After publish() is completer, puback_opt of {api-base}/++structasync__mqtt_1_1basic__client_1_1pubres__t.html++[pubres_t] is set. You can get puback packet.

Here is a code example that sending QoS1 PUBLISH packet.

```cpp
// MQTT publish QoS2 and wait response (pubrec, pubcomp receive)
auto pid_pub2 = co_await amcl.acquire_unique_packet_id_wait_until(as::use_awaitable); // async version
auto pubres2 = co_await amcl.publish(
    am::v5::publish_packet{
        pid_pub2,
        am::allocate_buffer("topic3"),
        am::allocate_buffer("payload3"),
        am::qos::exactly_once
    },
    as::use_awaitable
);
```

In order to create QoS2 PUBLISH packet, you need to acquire packet identifier. In this example, {api-base}/++classasync__mqtt_1_1basic__client.html#afbc77b4e603db0c1141d3235c8fa8b35++[acquire_unique_packet_id_wait_until()] is used. The CompletionToken parameter is packet identifier that not optional. If all packet identifiers are used, the function waits at least one of the packet identifier becomes usable again, and then invokes CompletionToken. It can help keeping user code simple.

After publish() is completer, pubrec_opt and pubcomp_opt of {api-base}/++structasync__mqtt_1_1basic__client_1_1pubres__t.html++[pubres_t] are set. You can get pubrec and pubcomp packet.

== Receive PUBLISH packet from the broker

=== {api-base}/++classasync__mqtt_1_1basic__client.html#aad1963132aa1d0c6458bd6f38d9b7e48++[recv()] funtion

```cpp
auto [publish_opt, disconnect_opt] = co_await amcl.recv(as::use_awaitable);
if (publish_opt) {
    std::cout << *publish_opt << std::endl;
}
else if (disconnect_opt) {
    std::cout << *disconnect_opt << std::endl;
}
```

After you called start() function, the received PUBLISH packets are stored in the clinet. You can get it using recv() function. If the no packets are stored, recv() waits until PUBLISH packet would be received.

CompletionToken parameters are error_code and publish_packet (optional), and disconnect_packet(optional). publish_packet or disconnect_packet has a value only if error_code is success.

== Send DISCONNECT packet

=== {api-base}/++classasync__mqtt_1_1basic__client.html#a13400c20164b4e0d2ed4d295cd6413d0++[disconnect()] funtion

```cpp
co_await amcl.disconnect(
    am::v5::disconnect_packet{},
    as::use_awaitable
);
```

CompletionToken parameters is error_code.
Sending DISCONNECT packet to the broker starts a glaceful disconnect sequence. The broker sends MQTT will message if needed and then disconnect the network connection from the broker side. And then, the client detects the disconnection, finally close the client side socket.

== Close

==== {api-base}/++classasync__mqtt_1_1basic__client.html#a4758d075939de30c77f3f4bdf0f7a4e1++[close()] funtion

```cpp
co_await amcl.close(as::use_awaitable);
```

CompletionToken parameters is nothing.
If you want to close the socket forcibly, you can call close() function. For example, no packets are received from the broker unexpectedly, but the client side doesn't detect disconnection.

== Whole code

* xref:{am-base-path}/example/cl_cpp20coro_mqtt.cpp[cl_cpp20coro_mqtt.cpp]
