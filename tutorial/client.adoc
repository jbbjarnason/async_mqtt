:last-update-label!:
:am-version: latest
:source-highlighter: rouge
:rouge-style: base16.monokai

ifdef::env-github[:am-base-path: ../../main]
ifndef::env-github[:am-base-path: ../..]
ifdef::env-github[:api-base: link:https://redboltz.github.io/async_mqtt/doc/{am-version}/html]
ifndef::env-github[:api-base: link:../api]

= Create client
First, choose MQTT protocol version (v3.1.1 or v5), and then choose underlying layer.

ifdef::env-github[image::../img/layer.svg[layer structure]]
ifndef::env-github[image::layer.svg[layer structure]]

== mqtt

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::client<am::protocol_version::v3_1_1, am::protocol::mqtt> amcl{
        ioc.get_executor() // args for underlying layer (mqtt)
        // mqtt is as::basic_stream_socket<as::ip::tcp, as::io_context::executor_type>
    );
```

== mqtts

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    am::client<am::protocol_version::v5, am::protocol::mqtts> amcl{
        ioc.get_executor(),  // args for underlying layer (as::ssl::stream<mqtt>)
        ctx
    );
```

NOTE: `tls` is namespace alias of `boost::asio::ssl` by default.

== ws

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::client<am::protocol_version::v3_1_1, am::protocol::ws> amcl{
    auto amep = am::endpoint<am::role::client, am::protocol::ws>::create(
        ioc.get_executor()  // args for underlying layer (bs::websocket::stream<mqtt>)
    );
```


== wss

```cpp
    as::io_context ioc;

    // To get IP address from hostname
    as::ip::tcp::socket resolve_sock{ioc};
    as::ip::tcp::resolver res{resolve_sock.get_executor()};

    am::tls::context ctx{am::tls::context::tlsv12};
    ctx.set_verify_mode(am::tls::verify_none);
    // If you want to check server certificate, set cacert as follows.
    // ctx.load_verify_file(cacert);

    am::client<am::protocol_version::v3_1_1, am::protocol::wss> amcl{
        ioc.get_executor(),  // args for underlying layer ( bs::websocket::stream<mqtts>)
        ctx                  // mqtts is as::ssl::stream<mqtt>
    );
```

== Layer access

|===
|Layer access | mqtt | mqtts | ws | wss

|next_layer()|TCP stream|TLS stream| WS stream | WS stream
|next_layer().next_layer()|-|TCP stream|TCP stream | TLS stream
|next_layer().next_layer().next_layer()|-|-|-|TCP stream
|lowest_layer()|TCP stream|TCP stream|TCP stream|TCP stream
|===

== Handshaking underlying layer

You can use underlying handshaking functions as follows:

```cpp
// Underlying TCP connect
co_await as::async_connect(
    amcl.next_layer(),
    eps,
    as::use_awaitable
);
std::cout << "TCP connected" << std::endl;
```

Similarly, handshake TLS, WebSocket layers if needed.

== Send MQTT CONNECT packet and start receive loop

After underlying layers' handshaking is completed, then start MQTT layer connection.

== {api-base}/++classasync__mqtt_1_1basic__client.html#a64c2b201c643fabc568865933b681f80++[start()] funtion



